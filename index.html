<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ItsAdi1982</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body { font-family: 'Poppins', sans-serif; }
    canvas { display: block; margin: auto; background: #111827; border-radius: 0.5rem; }
    .fade-in { animation: fadeIn 1s ease-in forwards; opacity: 0; }
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    .custom-cursor {
      cursor: url('https://cdn-icons-png.flaticon.com/512/590/590685.png'), auto;
    }
  </style>
</head>
<body class="bg-gray-900 text-white custom-cursor">
  <header class="text-center p-8 fade-in">
    <h1 class="text-4xl font-bold">Hey, I'm Aditya üëã</h1>
    <p class="text-xl mt-2">Coder. Gamer. Marvel Fan.</p>
  </header>

  <section class="max-w-4xl mx-auto p-4 fade-in">
    <h2 class="text-2xl font-semibold mb-2">About Me</h2>
    <p class="mb-4">
      I'm Aditya, a tech enthusiast who thrives in the world of coding and gaming. Whether it's crafting cool programs or diving into immersive games, I'm always ready to learn, build, and level up. When I‚Äôm not exploring game worlds, I‚Äôm usually learning new tech or vibing with some good series.
    </p>

    <h2 class="text-2xl font-semibold mb-2">üéÆ Favorite Games</h2>
    <table class="w-full text-left border border-gray-700 mb-4">
      <thead>
        <tr class="bg-gray-800">
          <th class="p-2">Platform</th>
          <th class="p-2">Games</th>
        </tr>
      </thead>
      <tbody>
        <tr class="border-t border-gray-700">
          <td class="p-2">Android</td>
          <td class="p-2">Shadow Fight 2, Swordigo, Alto‚Äôs Odyssey</td>
        </tr>
        <tr class="border-t border-gray-700">
          <td class="p-2">PC</td>
          <td class="p-2">Cave Story, GTA V, FarCry 3 & 4</td>
        </tr>
        <tr class="border-t border-gray-700">
          <td class="p-2">Console</td>
          <td class="p-2">The Last of Us I & II, God of War 3</td>
        </tr>
      </tbody>
    </table>

    <h2 class="text-2xl font-semibold mt-6 mb-2">üì∫ Favorite Series</h2>
    <ul class="list-disc ml-6">
      <li>Squid Game</li>
      <li>Alice in Borderland</li>
      <li>Dark</li>
      <li>Stranger Things</li>
      <li>Money Heist</li>
    </ul>
  </section>

  <section class="text-center p-6 fade-in">
  <h2 class="text-2xl font-bold mb-4">üéÆ Play a Game</h2>
  <div class="space-x-4 mb-4">
    <button onclick="switchGame('snake')" class="bg-green-500 px-4 py-2 rounded hover:bg-green-600">üêç Snake</button>
    <button onclick="switchGame('clicker')" class="bg-blue-500 px-4 py-2 rounded hover:bg-blue-600">üñ±Ô∏è Clicker</button>
    <button onclick="switchGame('brick')" class="bg-red-500 px-4 py-2 rounded hover:bg-red-600">üß± Brick Breaker</button>
  </div>
  <canvas id="gameCanvas" width="400" height="400" class="mx-auto mt-4"></canvas>
</section>

  <section class="text-center p-6 fade-in">
    <h2 class="text-xl font-semibold mb-2">üì¨ Contact</h2>
    <p>Discord: <code>itsadi1982</code></p>
    <p>GitHub: <a href="https://github.com/ItsAdi1982" class="text-blue-400 underline">ItsAdi1982</a></p>
  </section>

 <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  let currentGame = 'snake';

  // Shared values for Snake
  let snake, velocity, food, score, gameOver, started;
  const gridSize = 20;
  const tileCount = canvas.width / gridSize;

   // Brick Breaker Variables
let paddle, ball, bricks, brickRows = 5, brickCols = 7;
let brickWidth = 50, brickHeight = 20, ballSpeed = 4;

function initBrickGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height); // ‚úÖ Optional: clears old drawings

  paddle = {
    x: canvas.width / 2 - 40,
    y: canvas.height - 20,
    width: 80,
    height: 10
  };

  ball = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    dx: ballSpeed,
    dy: -ballSpeed,
    radius: 6
  };

  bricks = [];

  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      bricks.push({
        x: c * (brickWidth + 10) + 30,
        y: r * (brickHeight + 10) + 30,
        hit: false
      });
    }
  }

  document.addEventListener('mousemove', e => {
    if (currentGame !== 'brick') return;
    const rect = canvas.getBoundingClientRect();
    paddle.x = e.clientX - rect.left - paddle.width / 2;
  });
}

function drawBrickGame() {
  ctx.fillStyle = '#111827';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw paddle
  ctx.fillStyle = '#38bdf8';
  ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

  // Draw ball
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = '#facc15';
  ctx.fill();

  // Draw bricks
  for (let brick of bricks) {
    if (!brick.hit) {
      ctx.fillStyle = '#f87171';
      ctx.fillRect(brick.x, brick.y, brickWidth, brickHeight);
    }
  }

  // Ball movement
  ball.x += ball.dx;
  ball.y += ball.dy;

  // Wall collisions
  if (ball.x <= 0 || ball.x >= canvas.width) ball.dx *= -1;
  if (ball.y <= 0) ball.dy *= -1;
  if (ball.y >= canvas.height) {
    initBrickGame(); // Reset on fail
    return;
  }

  // Paddle collision
  if (
    ball.y + ball.radius >= paddle.y &&
    ball.x >= paddle.x &&
    ball.x <= paddle.x + paddle.width
  ) {
    ball.dy *= -1;
    ball.y = paddle.y - ball.radius;
  }

  // Brick collision
  for (let brick of bricks) {
    if (!brick.hit &&
        ball.x >= brick.x &&
        ball.x <= brick.x + brickWidth &&
        ball.y >= brick.y &&
        ball.y <= brick.y + brickHeight) {
      brick.hit = true;
      ball.dy *= -1;
      break;
    }
  }
}

  // Values for Clicker Game
  let clicks = 0;

  function switchGame(game) {
    currentGame = game;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (game === 'snake') initSnakeGame();
    else if (game === 'clicker') initClickerGame();
     else if (game === 'brick') initBrickGame();
  }

  function initSnakeGame() {
    snake = [{ x: 10, y: 10 }];
    velocity = { x: 0, y: 0 };
    food = { x: 5, y: 5 };
    score = 0;
    gameOver = false;
    started = false;
  }

  function drawSnakeGame() {
    if (gameOver) {
      ctx.fillStyle = 'red';
      ctx.font = '24px sans-serif';
      ctx.fillText("Game Over! Score: " + score, 50, canvas.height / 2);
      return;
    }

    ctx.fillStyle = '#111827';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawGrid();

    if (!started) {
      ctx.fillStyle = 'white';
      ctx.font = '18px sans-serif';
      ctx.fillText("Press Arrow Key to Start!", 80, canvas.height / 2);
      return;
    }

    const head = {
      x: (snake[0].x + velocity.x + tileCount) % tileCount,
      y: (snake[0].y + velocity.y + tileCount) % tileCount
    };
    snake.unshift(head);

    if (snake.slice(1).some(seg => seg.x === head.x && seg.y === head.y)) {
      gameOver = true;
    }

    if (head.x === food.x && head.y === food.y) {
      score++;
      food = {
        x: Math.floor(Math.random() * tileCount),
        y: Math.floor(Math.random() * tileCount),
      };
    } else {
      snake.pop();
    }

    ctx.fillStyle = '#facc15';
    ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize, gridSize);

    for (let i = 0; i < snake.length; i++) {
      ctx.fillStyle = i === 0 ? '#f87171' : '#4ade80';
      ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 1, gridSize - 1);
    }

    ctx.fillStyle = 'white';
    ctx.font = '18px sans-serif';
    ctx.fillText("Score: " + score, 10, 25);
  }

  function drawGrid() {
    ctx.strokeStyle = '#374151';
    for (let i = 0; i < tileCount; i++) {
      ctx.beginPath();
      ctx.moveTo(i * gridSize, 0);
      ctx.lineTo(i * gridSize, canvas.height);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, i * gridSize);
      ctx.lineTo(canvas.width, i * gridSize);
      ctx.stroke();
    }
  }

  function initClickerGame() {
    clicks = 0;
    canvas.addEventListener('click', handleClickerClick);
  }

  function handleClickerClick() {
    if (currentGame !== 'clicker') return;
    clicks++;
  }

  function drawClickerGame() {
    ctx.fillStyle = '#111827';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#38bdf8';
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 60, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = 'white';
    ctx.font = '24px sans-serif';
    ctx.fillText("Clicks: " + clicks, 140, 50);
    ctx.font = '18px sans-serif';
    ctx.fillText("Click the blue circle!", 120, canvas.height / 2 + 100);
  }

  window.addEventListener('keydown', e => {
    if (currentGame !== 'snake') return;
    e.preventDefault();
    if (gameOver) return location.reload();

    switch (e.key) {
      case 'ArrowUp': if (velocity.y === 0) velocity = { x: 0, y: -1 }; break;
      case 'ArrowDown': if (velocity.y === 0) velocity = { x: 0, y: 1 }; break;
      case 'ArrowLeft': if (velocity.x === 0) velocity = { x: -1, y: 0 }; break;
      case 'ArrowRight': if (velocity.x === 0) velocity = { x: 1, y: 0 }; break;
    }
     if (!started) started = true;
  } else if (currentGame === 'pong') {
    if (e.key === 'ArrowUp') pong.paddleLeft.y -= 20;
    if (e.key === 'ArrowDown') pong.paddleLeft.y += 20;
  }
});

    if (!started) started = true;
  });

  let snakeTick = 0;

// ================= Pong Game =================
let pong = {
  paddleLeft: { x: 10, y: 100, width: 10, height: 80 },
  paddleRight: { x: canvas.width - 20, y: 100, width: 10, height: 80 },
  ball: { x: canvas.width / 2, y: canvas.height / 2, dx: 4, dy: 4, radius: 6 },
  leftScore: 0,
  rightScore: 0
};

function initPongGame() {
  pong.paddleLeft.y = 100;
  pong.paddleRight.y = 100;
  pong.ball = { x: canvas.width / 2, y: canvas.height / 2, dx: 4, dy: 4, radius: 6 };
}

function drawPongGame() {
  ctx.fillStyle = '#111827';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw paddles
  ctx.fillStyle = '#38bdf8';
  ctx.fillRect(pong.paddleLeft.x, pong.paddleLeft.y, pong.paddleLeft.width, pong.paddleLeft.height);
  ctx.fillRect(pong.paddleRight.x, pong.paddleRight.y, pong.paddleRight.width, pong.paddleRight.height);

  // Draw ball
  ctx.beginPath();
  ctx.arc(pong.ball.x, pong.ball.y, pong.ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = '#facc15';
  ctx.fill();

  // Move ball
  pong.ball.x += pong.ball.dx;
  pong.ball.y += pong.ball.dy;

  // Bounce top/bottom
  if (pong.ball.y <= 0 || pong.ball.y >= canvas.height) pong.ball.dy *= -1;

  // Bounce off paddles
  if (
    pong.ball.x - pong.ball.radius < pong.paddleLeft.x + pong.paddleLeft.width &&
    pong.ball.y > pong.paddleLeft.y &&
    pong.ball.y < pong.paddleLeft.y + pong.paddleLeft.height
  ) pong.ball.dx *= -1;

  if (
    pong.ball.x + pong.ball.radius > pong.paddleRight.x &&
    pong.ball.y > pong.paddleRight.y &&
    pong.ball.y < pong.paddleRight.y + pong.paddleRight.height
  ) pong.ball.dx *= -1;

  // Score system
  if (pong.ball.x <= 0) {
    pong.rightScore++;
    initPongGame();
  } else if (pong.ball.x >= canvas.width) {
    pong.leftScore++;
    initPongGame();
  }

  // AI for right paddle
  pong.paddleRight.y += (pong.ball.y - pong.paddleRight.y - pong.paddleRight.height / 2) * 0.1;

  // Draw scores
  ctx.fillStyle = 'white';
  ctx.font = '20px sans-serif';
  ctx.fillText(pong.leftScore, canvas.width / 4, 30);
  ctx.fillText(pong.rightScore, canvas.width * 3 / 4, 30);
}

// ================= Tic Tac Toe Game =================
let board = [
  ['', '', ''],
  ['', '', ''],
  ['', '', '']
];
let currentPlayer = 'X';
let tttGameOver = false;

function initTicTacToe() {
  board = [
    ['', '', ''],
    ['', '', ''],
    ['', '', '']
  ];
  currentPlayer = 'X';
  tttGameOver = false;

  canvas.addEventListener('click', handleTicTacToeClick);
}

function drawTicTacToeGame() {
  ctx.fillStyle = '#111827';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const size = canvas.width / 3;

  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;

  for (let i = 1; i < 3; i++) {
    ctx.beginPath();
    ctx.moveTo(i * size, 0);
    ctx.lineTo(i * size, canvas.height);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, i * size);
    ctx.lineTo(canvas.width, i * size);
    ctx.stroke();
  }

  ctx.font = '60px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  for (let r = 0; r < 3; r++) {
    for (let c = 0; c < 3; c++) {
      const val = board[r][c];
      if (val !== '') {
        ctx.fillStyle = val === 'X' ? '#f87171' : '#38bdf8';
        ctx.fillText(val, c * size + size / 2, r * size + size / 2);
      }
    }
  }

  if (tttGameOver) {
    ctx.fillStyle = 'white';
    ctx.font = '24px sans-serif';
    ctx.fillText('Game Over! Click to restart.', canvas.width / 2, canvas.height - 20);
  }
}

function handleTicTacToeClick(e) {
  if (currentGame !== 'tictactoe') return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const row = Math.floor(y / (canvas.height / 3));
  const col = Math.floor(x / (canvas.width / 3));

  if (tttGameOver || board[row][col] !== '') return;

  board[row][col] = currentPlayer;
  if (checkWin(currentPlayer)) {
    tttGameOver = true;
  } else {
    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
  }
}

function checkWin(player) {
  for (let i = 0; i < 3; i++) {
    if (board[i][0] === player && board[i][1] === player && board[i][2] === player) return true;
    if (board[0][i] === player && board[1][i] === player && board[2][i] === player) return true;
  }

  if (board[0][0] === player && board[1][1] === player && board[2][2] === player) return true;
  if (board[0][2] === player && board[1][1] === player && board

function gameLoop() {
  if (currentGame === 'snake') {
    snakeTick++;
    if (snakeTick % 10 === 0) drawSnakeGame();
  } else if (currentGame === 'clicker') {
    drawClickerGame();
  } else if (currentGame === 'brick') {
    drawBrickGame();
  } else if (currentGame === 'pong') {
    drawPongGame();
  } else if (currentGame === 'tictactoe') {
    drawTicTacToeGame();
  }

  requestAnimationFrame(gameLoop);
}

  initSnakeGame();
  gameLoop();
</script>
</body>
</html>
